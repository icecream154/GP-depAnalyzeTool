数据输入：
    进入算法迭代的模型包括三项：

    ①代表源代码文件的[节点集合]：
        输入项目目录。遍历项目中所有源代码文件，将每一个文件映射为[节点Node]。
    ②代表源代码文件之间依赖关系的[边集合]
        对项目目录运用depends等项目依赖分析工具，得到代表代码间依赖的边Edge。
        边仅具有数值，代表代码间的依赖程度，是一个绝对值。
    ③对节点划分后的初始[模块集合]，由项目目录结构生成，模块中包含若干节点。


算法迭代：
    分析的基本对象：[节点]对于[模块]的依赖[ModuleDependency]
    ModuleDependency包含两个属性：①依赖类型(枚举类型Import, Attribute, Func, Struct) ②依赖程度(归一化至0-1的数值[A1])

    ModuleDependency是否合理取决于：
        同一模块内的所有节点对于其他所有模块的依赖是否同质（即模块内的节点是否保持类似的外部依赖性）

    迭代算法：
        分析阶段：
            对于一个模块M中所有节点，给出每一个[节点]对其他所有[模块]的依赖组成的向量V。
            分析所有节点的向量V，使用节点ModuleDependency向量模式发现算法[A2]，输出以下信息：
                ①模块外部依赖模式[ModuleSpecification]，模式包含该模块对于其他每一个模块依赖区间与依赖均值两个向量。
                    依赖区间向量：<[0.2-0.3], [0.4-0.6], [0-0.1]>
                    依赖均值向量：<0.27, 0.52, 0.05>
                ②符合ModuleSpecification的节点列表(ModuleSpecification的区间就由该列表的极值决定)
                ③不符合ModuleSpecification的节点列表
                ④ModuleSpecification的收敛水平(平均区间差异——上述ModuleSpecification非零平均区间差异为(0.1+0.2+0.1)/3=0.133)
                    定义阈值α=0.25，β=0.5
                    - 收敛：平均区间差异<=α
                    - 分散：α<平均区间差异<=β
                    - 稀疏：平均区间差异>β

            说明：采用向量对模块内的节点进行整体分析，而不对每一个模块单独分析，原因在于：同一节点组的外部依赖是否类似取决于架构设计。
               如果节点组内的节点依赖整体趋同，比如都属于架构中的某一层，那么ModuleSpecification会大概率被判定为收敛，算法能够发现不匹配模式的节点；
               而如果节点组内的节点对于外部的依赖本身较为稀疏，那么在设计中该模块本身的职责可能尚未明确，分析得到的模式并无太大的实际含义。

        变更阶段：
            节点与ModuleSpecification的距离计算公式：<实际依赖向量> 到 <目标模块依赖均值向量> 的欧几里得距离。(不考虑到待变更节点所在的模块)
                ①对于不符合ModuleSpecification的所有节点，遍历匹配所有[收敛]的ModuleSpecification。如果成功匹配，变更该节点所属的模块。
                ②对于依旧尚未匹配模块的节点，遍历匹配所有[分散]的ModuleSpecification。如果成功匹配，变更该节点所属的模块。
                ③对于依旧尚未匹配模块的节点，遍历计算到所有[稀疏]ModuleSpecification的距离，如果成功匹配，变更该节点所属的模块。
                *④剩余的节点使用稀疏节点模块划分算法[A3]，得到新的若干模块。

    [A1]: L2范数归一化模块依赖程度
        对于一个模块M，给出所有不属于模块M但依赖模块M的节点列表A。对A中每一个节点，求出对模块M的依赖次数之和，得到节点模块依赖列表。
        对该列表使用L2范数归一化，得到节点对于模块M的依赖程度。
        例如：模块M包含三个节点 m1,m2,m3。依赖模块M的节点共四个a,b,c,d.
            E(x,y)=k 表示 节点x依赖k次节点y; MD(x,M)=k 表示 节点x对模块M的依赖程度为k.
                E(a, m1)=3, E(a, m2)=1, E(a, m3)=0; SumE(a, M)=4; MD(d, M)=0.422;
                E(b, m1)=0, E(b, m2)=2, E(b, m3)=1; SumE(b, M)=3; MD(d, M)=0.316;
                E(c, m1)=5, E(c, m2)=0, E(c, m3)=3; SumE(c, M)=8; MD(d, M)=0.843;
                E(d, m1)=1, E(d, m2)=0, E(d, m3)=0; SumE(d, M)=1; MD(d, M)=0.105;

        归一化原因：
            在衡量一个节点是否应该属于某一个模块时，要对该节点对于其他节点的相似程度进行判断。此时需要屏蔽模块之间在被依赖次数上的绝对值
            差异，而比较相对的依赖程度。例如节点N依赖了3次模块A，依赖了15c次模块B。如果其他依赖相应模块的节点基本上都只依赖3次模块A，
            依赖15次模块B，那么应该认为N对于模块A和B的依赖程度相同。因此需要对于绝对的依赖次数归一化处理。

        使用L2范数归一化的原因：
            在归一化的同时，需要保持依赖次数原有的相对关系，区别不同依赖次数的差异。同时要保证0值语义不变性，0依旧表示不存在该种类型的
            依赖。L2范数归一化能够很好地满足这些特性。

    [A2]: 模块节点ModuleDependency向量模式发现算法
        算法输入：一组代表模块M内所有节点的外部依赖向量集合V
            例如 V = {<0.15, 0, 0.38, 0.2, 0>, <0.2, 0, 0.32, 0.27, 0>, <0, 0.35, 0, 0.05, 0>, <0.22, 0.05, 0.23, 0.4, 0>}
        该算法需要解决一个二分类问题，即将数据集V划分为[规范集]与[异常集]。其中规范集中的向量具有相似性，异常集中的向量与规范集中的向量
        相似性很低。([规范集]相当于符合ModuleSpecification的节点列表，[异常集]相当于不符合ModuleSpecification的节点列表)

        划分算法：
            定义规范集[Ce]与异常集[Ca]，其中异常集[Ca]可能为空集
            定义扩展系数β=0.25
            单次划分：
                STEP0: 定义集合Ce=∅, Ca=∅，所有向量的集合为V。
                STEP1: 向量p = 选取集合中的一个向量v。Ce = Ce + {v}, V = V - {v}。
                STEP2: 若V!=∅，计算V中所有与Ce中向量的距离，找出所有距离中最小的d。其中d=|v'-v| v'∈V, v∈Ce；否则进入STEP3。
                        若d <= Ce中两点间距最大值*(1+β)，则Ce = Ce + {v'}, C = C - {v'}，重复STEP2;
                        若不满足，则Ca = Ca + {v'}, C = C - {v'}，重复STEP2;
                STEP3: 得到集合Ce与Ca
            选取V中的每个v作为单次划分中STEP1的首个向量，重复STEP0-STEP4，每次得到一个Ce与Ca，返回出现次数最多的划分。

        模式生成：
            对于[规范集]中的所有向量，取每一个分量上的最大最小值，形成[外部依赖模式]在该分量上的区间

        收敛水平：
            对于模式中在分量上区间非0值的所有分量，计算各个区间的跨度平均值——平均区间差异
            定义阈值α=0.2，β=0.4
                - 收敛：平均区间差异<=α
                - 分散：α<平均区间差异<=β
                - 稀疏：平均区间差异>β

        输出结果：
            [规范集]，[异常集]，[外部依赖模式], [收敛水平]
            例如 V = {<0.15, 0, 0.38, 0.2, 0>, <0.2, 0, 0.32, 0.27, 0>, <0, 0.35, 0, 0.05, 0>, <0.22, 0.05, 0.23, 0.4, 0>}
            那么各项输出为：
                [规范集] = {<0.15, 0, 0.38, 0.2, 0>, <0.2, 0, 0.32, 0.27, 0>, <0.22, 0.05, 0.23, 0.4, 0>}
                [异常集] = {<0, 0.35, 0, 0.05, 0>}
                [外部依赖模式] = <[0.15-0.22], [0-0.05], [0.23-0.38], [0.2-0.4], {0}>
                [平均区间差异] = (0.07 + 0.05 + 0.15 + 0.2) / 4 = 0.118
                [收敛水平] = 收敛


    *[A3]：稀疏节点模块划分算法
        算法输入：稀疏模块中节点构成的集合，对于集合中的每一个节点，取该节点对于收敛与分散模块的依赖组成节点的外部依赖向量。
        例如 V = {<0.44, 0.38, 0, 0>, <0.39, 0.46, 0, 0>, <0.39, 0.5, 0, 0>, <0, 0.1, 0.48, 0>, <0, 0.05, 0.54, 0>}

        基于模块合并的划分算法:
            初始情况下，每一个节点组成一个单独的模块M。定义两个模块P，Q间的距离为：(Min(d(p1, q1)) + Max(d(p2, q2))) / 2
            其中p1, p2∈P，q1, q2∈Q。

            定义扩展系数β=0.25
            迭代过程：
                STEP0: 计算所有模块间距离，其中模块P与Q之间的距离d(P, Q)是最小的。
                STEP1: 计算P或Q的接纳距离。对于当前仅包含单个向量的模块，接纳距离为+∞；对于当前包含多个节点的模块，
                       接纳距离为模块内节点最大距离*(1+β)。
                STEP2：如果d <= min(P的接纳距离,Q的接纳距离)，合并P Q。否则取下一个模块间距离继续判断是否能够合并。
                       如果没有可以合并的模块，迭代结束。

        输出结果:
            M1 = {<0.44, 0.38, 0, 0>, <0.39, 0.46, 0, 0>, <0.39, 0.5, 0, 0>}
            M2 = {<0, 0.1, 0.48, 0>, <0, 0.05, 0.54, 0>}

数据输出：
    迭代若干次后，得到最终对于项目的若干模块划分。
    每一个模块包含以下信息：
        ①包含的节点(源码文件)列表
        ②依赖的模块列表
        ③是否来自项目目录路径生成的初始模块

    反馈给用户的信息：
        ①节点的模块变更(从一个初始模块移动至另一个初始模块，或一个新构建的模块)
        ②模块外部依赖模式ModuleSpecification，即这个模块应该对哪些模块存在依赖
        ③模块外部依赖模式ModuleSpecification的收敛水平，代表该模块是否内聚