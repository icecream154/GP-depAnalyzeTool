算法：
    ①依赖聚合
        步骤目的：通过节点与节点之间的依赖情况来描述节点组与节点组之间的依赖
        步骤描述：
            定义[组依赖]为节点组与节点组之间的依赖(包括节点组的自依赖)。
            节点组A对节点组P的[组依赖]包含以下数据：
            - 依赖向量：描述节点组A内每一节点对节点组P的[依赖程度]，依赖程度是一个[0-1]之间的值，例如<0.293, 0.341, 0, 0.725>
                依赖程度需要根据依赖次数标准化至[0-1]之间。
                    [Import,Struct]使用二分策略:
                         - 存在该种依赖则依赖程度为1
                         - 不存在该种依赖则依赖程度为0
                    [Const,Variable,Func]使用标准化算法：
                        - 不存在该种依赖，依赖程度为0
                        - 存在该种依赖的[节点集合]S对某一节点组P在某一类型上的依赖程度，由S中所有节点组对节点组P的依赖次数标准化得到。
                            如 ABCD对P有Func依赖，ABCD4个节点构成集合S，对节点组P的Func依赖次数之和分别为2、5、8、9。
                            即每一个节点共调用了节点组P中的方法2、5、8、9次(不区分是否为不同方法)。
                            L2范数归一化得到的依赖程度为(0.135, 0.409, 0.683, 0.774)
                            (*可以进一步考虑对于不同方法的依赖情况，得到更细粒度的依赖程度)
            - 依赖均值：节点组A中单个节点对于节点组P的平均依赖程度，上例中 <0.293, 0.341, 0, 0.725> 的依赖均值为 0.33975
            - 依赖离散度：依赖向量的标准差, 上例中 <0.293, 0.341, 0, 0.725> 的依赖离散度为 0.257893，
                        代表了组内各个节点对于节点组P依赖的差异程度

    ②差异判断
        步骤目的：
            通过分析不同节点组对同一节点组的组依赖来分析是否存在差异性极大的组依赖。
            将对节点组P存在依赖的节点组分为两类：预期类[Ce]与 异常类[Ca]，其中异常类[Ca]可能为空集
        步骤描述：
            假设节点组对节点组P的组依赖的依赖向量分别为V1,V2,...Vn，依赖均值为m1,m2,...mn，依赖离散度为σ1,σ2,...σn。
            节点V的[均值离散向量]为(m,σ)
            case1:
                V1 = <0.2, 0.3, 0, 0.7>             m1 = 0.300      σ1 = 0.254951
                V2 = <0.4, 0.6, 0.2>                m2 = 0.400      σ2 = 0.163299
                V3 = <0, 0.14, 0>                   m3 = 0.047      σ3 = 0.065997
                V4 = <0.45, 0.28, 0.31, 0, 0.33>    m4 = 0.274      σ4 = 0.148674
                V5 = <0.8, 0, 0>                    m5 = 0.267      σ5 = 0.377124

            case2:
                V1 = <0.4, 0, 0, 0.1>               m1 = 0.125      σ1 = 0.163936
                V2 = <0, 0, 0.2>                    m2 = 0.067      σ2 = 0.094281
                V3 = <0, 0.15, 0>                   m3 = 0.050      σ3 = 0.070711
                V4 = <0.3, 0.1, 0, 0, 0>            m4 = 0.080      σ4 = 0.116619

            算法步骤：
                定义扩展系数β=0.25

                STEP0: 定义向量集合Ce=∅, Ca=∅，所有均值离散向量的集合为C。
                STEP1: 向量p = 随机选取集合中的一个节点V的[均值离散向量](m,σ)。Ce = Ce + {p}, C = C - {P}。
                STEP2: 若C!=∅，计算C中所有与Ce中节点的距离，找出所有距离中最小的d。其中d=|p'-p| p'∈C, p∈Ci (i=1,2)；
                       否则进入STEP3。
                        若d <= Ce中两点间距最大值*(1+β)，则Ce = Ce + {p'}, C = C - {p'}，重复STEP2;
                        若不满足，则Ca = Ca + {p'}, C = C - {p'}，重复STEP2;
                STEP3: 得到集合Ce与Ca

                重复STEP0-STEP4，每次得到一个Ce与Ca，当划分出现次数超过半数时，返回该种划分。
